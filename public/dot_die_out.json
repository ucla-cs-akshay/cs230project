{
    "search": {
        "results": {
            "results": [
                {
                    "__typename": "FileMatch",
                    "repository": {
                        "name": "github.com/pcottle/learnGitBranching",
                        "url": "/github.com/pcottle/learnGitBranching"
                    },
                    "file": {
                        "name": "index.js",
                        "path": "src/js/level/index.js",
                        "url": "/github.com/pcottle/learnGitBranching/-/blob/src/js/level/index.js",
                        "content": "var Q = require('q');\nvar React = require('react');\nvar ReactDOM = require('react-dom');\n\nvar util = require('../util');\nvar Main = require('../app');\nvar intl = require('../intl');\nvar log = require('../log');\n\nvar Errors = require('../util/errors');\nvar Sandbox = require('../sandbox/').Sandbox;\nvar GlobalStateActions = require('../actions/GlobalStateActions');\nvar GlobalStateStore = require('../stores/GlobalStateStore');\nvar LevelActions = require('../actions/LevelActions');\nvar LevelStore = require('../stores/LevelStore');\nvar Visualization = require('../visuals/visualization').Visualization;\nvar DisabledMap = require('../level/disabledMap').DisabledMap;\nvar GitShim = require('../git/gitShim').GitShim;\nvar Commands = require('../commands');\n\nvar MultiView = require('../views/multiView').MultiView;\nvar CanvasTerminalHolder = require('../views').CanvasTerminalHolder;\nvar ConfirmCancelTerminal = require('../views').ConfirmCancelTerminal;\nvar NextLevelConfirm = require('../views').NextLevelConfirm;\nvar LevelToolbarView = require('../react_views/LevelToolbarView.jsx');\n\nvar TreeCompare = require('../graph/treeCompare');\n\nvar regexMap = {\n  'help level': /^help level$/,\n  'start dialog': /^start dialog$/,\n  'show goal': /^(show goal|goal|help goal)$/,\n  'hide goal': /^hide goal$/,\n  'show solution': /^show solution($|\\s)/,\n  'objective': /^(objective|assignment)$/\n};\n\nvar parse = util.genParseCommand(regexMap, 'processLevelCommand');\n\nvar Level = Sandbox.extend({\n  initialize: function(options) {\n    options = options || {};\n    options.level = options.level || {};\n\n    this.level = options.level;\n\n    this.gitCommandsIssued = [];\n    this.solved = false;\n    this.wasResetAfterSolved = false;\n\n    this.initGoalData(options);\n    this.initName(options);\n    this.on('minimizeCanvas', this.minimizeGoal);\n    this.on('resizeCanvas', this.resizeGoal);\n    this.isGoalExpanded = false;\n\n    Level.__super__.initialize.apply(this, [options]);\n    this.startOffCommand();\n\n    this.handleOpen(options.deferred);\n  },\n\n  getIsGoalExpanded: function() {\n    return this.isGoalExpanded;\n  },\n\n  handleOpen: function(deferred) {\n    deferred = deferred || Q.defer();\n\n    // if there is a multiview in the beginning, open that\n    // and let it resolve our deferred\n    if (GlobalStateStore.getShouldDisableLevelInstructions()) {\n      setTimeout(function() {\n        deferred.resolve();\n      }, 100);\n      return;\n    }\n\n    if (this.level.startDialog && !this.testOption('noIntroDialog')) {\n      new MultiView(Object.assign(\n        {},\n        intl.getStartDialog(this.level),\n        { deferred: deferred }\n      ));\n      return;\n    }\n\n    // otherwise, resolve after a 700 second delay to allow\n    // for us to animate easily\n    setTimeout(function() {\n      deferred.resolve();\n    }, this.getAnimationTime() * 1.2);\n  },\n\n  objectiveDialog: function(command, deferred, levelObj) {\n    levelObj = (levelObj === undefined) ? this.level : levelObj;\n\n    if (!levelObj || !levelObj.startDialog) {\n      command.set('error', new Errors.GitError({\n        msg: intl.str('no-start-dialog')\n      }));\n      deferred.resolve();\n      return;\n    }\n\n    var dialog = $.extend({}, intl.getStartDialog(levelObj));\n    // grab the last slide only\n    dialog.childViews = dialog.childViews.slice(-1);\n    new MultiView(Object.assign(\n      dialog,\n      { deferred: deferred }\n    ));\n\n    // when its closed we are done\n    deferred.promise.then(function() {\n      command.set('status', 'finished');\n    });\n  },\n\n  startDialog: function(command, deferred) {\n    if (!this.level.startDialog) {\n      command.set('error', new Errors.GitError({\n        msg: intl.str('no-start-dialog')\n      }));\n      deferred.resolve();\n      return;\n    }\n\n    this.handleOpen(deferred);\n    deferred.promise.then(function() {\n      command.set('status', 'finished');\n    });\n  },\n\n  getEnglishName: function() {\n    return this.level.name.en_US;\n  },\n\n  initName: function() {\n    var name = intl.getName(this.level);\n    this.levelToolbar = React.createElement(\n      LevelToolbarView,\n      {\n        name: name,\n        onGoalClick: this.toggleGoal.bind(this),\n        onObjectiveClick: this.toggleObjective.bind(this),\n        parent: this\n      }\n    );\n    ReactDOM.render(\n      this.levelToolbar,\n      document.getElementById('levelToolbarMount')\n    );\n  },\n\n  initGoalData: function(options) {\n    if (!this.level.goalTreeString || !this.level.solutionCommand) {\n      throw new Error('need goal tree and solution');\n    }\n  },\n\n  takeControl: function() {\n    Main.getEventBaton().stealBaton('processLevelCommand', this.processLevelCommand, this);\n\n    Level.__super__.takeControl.apply(this);\n  },\n\n  releaseControl: function() {\n    Main.getEventBaton().releaseBaton('processLevelCommand', this.processLevelCommand, this);\n\n    Level.__super__.releaseControl.apply(this);\n  },\n\n  startOffCommand: function() {\n    var method = this.options.command.get('method');\n    if (GlobalStateStore.getShouldDisableLevelInstructions()) {\n      Main.getEventBaton().trigger(\n        'commandSubmitted',\n        'hint; show goal'\n      );\n      return;\n    }\n\n    if (!this.testOption('noStartCommand') && method !== 'importLevelNow') {\n      Main.getEventBaton().trigger(\n        'commandSubmitted',\n        'hint; delay 2000; show goal'\n      );\n    }\n  },\n\n  initVisualization: function(options) {\n    this.mainVis = new Visualization({\n      el: options.el || this.getDefaultVisEl(),\n      treeString: options.level.startTree\n    });\n  },\n\n  initGoalVisualization: function() {\n    var onlyMain = TreeCompare.onlyMainCompared(this.level);\n    // first we make the goal visualization holder\n    this.goalCanvasHolder = new CanvasTerminalHolder({\n      text: (onlyMain) ? intl.str('goal-only-main') : undefined,\n      parent: this\n    });\n\n    // then we make a visualization. the \"el\" here is the element to\n    // track for size information. the container is where the canvas will be placed\n    this.goalVis = new Visualization({\n      el: this.goalCanvasHolder.getCanvasLocation(),\n      containerElement: this.goalCanvasHolder.getCanvasLocation(),\n      treeString: this.level.goalTreeString,\n      noKeyboardInput: true,\n      smallCanvas: true,\n      isGoalVis: true,\n      levelBlob: this.level,\n      noClick: true\n    });\n\n    // If the goal visualization gets dragged to the right side of the screen, then squeeze the main\n    // repo visualization a bit to make room. This way, you could have the goal window hang out on\n    // the right side of the screen and still see the repo visualization.\n    this.goalVis.customEvents.on('drag', function(event, ui) {\n      if (ui.position.left > 0.5 * $(window).width()) {\n        if (!$('#goalPlaceholder').is(':visible')) {\n          $('#goalPlaceholder').show();\n          this.mainVis.myResize();\n        }\n      } else {\n        if ($('#goalPlaceholder').is(':visible')) {\n          $('#goalPlaceholder').hide();\n          this.mainVis.myResize();\n        }\n      }\n    }.bind(this));\n\n    return this.goalCanvasHolder;\n  },\n\n  minimizeGoal: function (position, size) {\n    this.isGoalExpanded = false;\n    this.trigger('goalToggled');\n    this.goalVis.hide();\n    this.goalWindowPos = position;\n    this.goalWindowSize = size;\n    if ($('#goalPlaceholder').is(':visible')) {\n      $('#goalPlaceholder').hide();\n      this.mainVis.myResize();\n    }\n  },\n\n  resizeGoal: function () {\n    if (!this.goalVis) {\n      return;\n    }\n    this.goalVis.myResize();\n  },\n\n  showSolution: function(command, deferred) {\n    var toIssue = this.level.solutionCommand;\n    var issueFunc = function() {\n      this.isShowingSolution = true;\n      Main.getEventBaton().trigger(\n        'commandSubmitted',\n        toIssue\n      );\n      log.showLevelSolution(this.getEnglishName());\n    }.bind(this);\n\n    var commandStr = command.get('rawStr');\n    if (!this.testOptionOnString(commandStr, 'noReset')) {\n      toIssue = 'reset --forSolution; ' + toIssue;\n    }\n    if (this.testOptionOnString(commandStr, 'force')) {\n      issueFunc();\n      command.finishWith(deferred);\n      return;\n    }\n\n    // allow them for force the solution\n    var confirmDefer = Q.defer();\n    var dialog = intl.getDialog(require('../dialogs/confirmShowSolution'))[0];\n    var confirmView = new ConfirmCancelTerminal({\n      markdowns: dialog.options.markdowns,\n      deferred: confirmDefer\n    });\n\n    confirmDefer.promise\n    .then(issueFunc)\n    .fail(function() {\n      command.setResult(\"\");\n    })\n    .done(function() {\n     // either way we animate, so both options can share this logic\n     setTimeout(function() {\n        command.finishWith(deferred);\n      }, confirmView.getAnimationTime());\n    });\n  },\n\n  toggleObjective: function() {\n    Main.getEventBaton().trigger(\n      'commandSubmitted',\n      'objective'\n    );\n  },\n\n  toggleGoal: function () {\n    if (this.goalCanvasHolder && this.goalCanvasHolder.inDom) {\n      this.hideGoal();\n    } else {\n      this.showGoal();\n    }\n  },\n\n  showGoal: function(command, defer) {\n    this.isGoalExpanded = true;\n    this.trigger('goalToggled');\n    this.showSideVis(command, defer, this.goalCanvasHolder, this.initGoalVisualization);\n    // show the squeezer again we are to the side\n    if ($(this.goalVis.el).offset().left > 0.5 * $(window).width()) {\n      $('#goalPlaceholder').show();\n      this.mainVis.myResize();\n    }\n  },\n\n  showSideVis: function(command, defer, canvasHolder, initMethod) {\n    var safeFinish = function() {\n      if (command) { command.finishWith(defer); }\n    };\n    if (!canvasHolder || !canvasHolder.inDom) {\n      canvasHolder = initMethod.apply(this);\n    }\n\n    canvasHolder.restore(this.goalWindowPos, this.goalWindowSize);\n    setTimeout(safeFinish, canvasHolder.getAnimationTime());\n  },\n\n  hideGoal: function(command, defer) {\n    this.isGoalExpanded = false;\n    this.trigger('goalToggled');\n    this.hideSideVis(command, defer, this.goalCanvasHolder);\n  },\n\n  hideSideVis: function(command, defer, canvasHolder, vis) {\n    var safeFinish = function() {\n      if (command) { command.finishWith(defer); }\n    };\n\n    if (canvasHolder && canvasHolder.inDom) {\n      canvasHolder.die();\n      setTimeout(safeFinish, canvasHolder.getAnimationTime());\n    } else {\n      safeFinish();\n    }\n  },\n\n  initParseWaterfall: function(options) {\n    Level.__super__.initParseWaterfall.apply(this, [options]);\n\n    // add our specific functionality\n    this.parseWaterfall.addFirst(\n      'parseWaterfall',\n      parse\n    );\n\n    this.parseWaterfall.addFirst(\n      'instantWaterfall',\n      this.getInstantCommands()\n    );\n\n    // if we want to disable certain commands...\n    if (options.level.disabledMap) {\n      // disable these other commands\n      this.parseWaterfall.addFirst(\n        'instantWaterfall',\n        new DisabledMap({\n          disabledMap: options.level.disabledMap\n        }).getInstantCommands()\n      );\n    }\n  },\n\n  initGitShim: function(options) {\n    // ok we definitely want a shim here\n    this.gitShim = new GitShim({\n      beforeCB: this.beforeCommandCB.bind(this),\n      afterCB: this.afterCommandCB.bind(this),\n      afterDeferHandler: this.afterCommandDefer.bind(this)\n    });\n  },\n\n  undo: function() {\n    this.gitCommandsIssued.pop();\n    Level.__super__.undo.apply(this, arguments);\n  },\n\n  beforeCommandCB: function(command) {\n    // Alright we actually no-op this in the level subclass\n    // so we can tell if the command counted or not... kinda :P\n    // We have to save the state in this method since the git\n    // engine will change by the time afterCommandCB runs\n    this._treeBeforeCommand = this.mainVis.gitEngine.printTree();\n  },\n\n  afterCommandCB: function(command) {\n    if (this.doesCommandCountTowardsTotal(command)) {\n      // Count it as a command AND...\n      this.gitCommandsIssued.push(command.get('rawStr'));\n      // add our state for undo since our undo pops a command.\n      //\n      // Ugly inheritance overriding on private implementations ahead!\n      this.undoStack.push(this._treeBeforeCommand);\n    }\n  },\n\n  doesCommandCountTowardsTotal: function(command) {\n    if (command.get('error')) {\n      // don't count errors towards our count\n      return false;\n    }\n\n    var matched = false;\n    var commandsThatCount = Commands.commands.getCommandsThatCount();\n    Object.values(commandsThatCount).forEach(function(map) {\n      Object.values(map).forEach(function(regex) {\n        matched = matched || regex.test(command.get('rawStr'));\n      });\n    });\n    return matched;\n  },\n\n  afterCommandDefer: function(defer, command) {\n    if (this.solved) {\n      command.addWarning(intl.str('already-solved'));\n      defer.resolve();\n      return;\n    }\n\n    var current = this.mainVis.gitEngine.printTree();\n    var solved = TreeCompare.dispatchFromLevel(this.level, current);\n\n    if (!solved) {\n      defer.resolve();\n      return;\n    }\n\n    // woohoo!!! they solved the level, lets animate and such\n    this.levelSolved(defer);\n  },\n\n  getNumSolutionCommands: function() {\n    // strip semicolons in bad places\n    var toAnalyze = this.level.solutionCommand.replace(/^;|;$/g, '');\n    return toAnalyze.split(';').length;\n  },\n\n  testOption: function(option) {\n    return this.options.command && new RegExp('--' + option).test(this.options.command.get('rawStr'));\n  },\n\n  testOptionOnString: function(str, option) {\n    return str && new RegExp('--' + option).test(str);\n  },\n\n  levelSolved: function(defer) {\n    this.solved = true;\n    if (!this.isShowingSolution) {\n      LevelActions.setLevelSolved(this.level.id);\n      log.levelSolved(this.getEnglishName());\n    }\n\n    this.hideGoal();\n\n    var nextLevel = LevelStore.getNextLevel(this.level.id);\n    var numCommands = this.gitCommandsIssued.length;\n    var best = this.getNumSolutionCommands();\n\n    var skipFinishDialog = this.testOption('noFinishDialog') ||\n      this.wasResetAfterSolved;\n    var skipFinishAnimation = this.wasResetAfterSolved;\n\n    if (!skipFinishAnimation) {\n      GlobalStateActions.levelSolved();\n    }\n\n    /**\n     * Speed up the animation each time we see it.\n     */\n    var speed = 1.0;\n    switch (GlobalStateStore.getNumLevelsSolved()) {\n      case 2:\n        speed = 1.5;\n        break;\n      case 3:\n        speed = 1.8;\n        break;\n      case 4:\n        speed = 2.1;\n        break;\n      case 5:\n        speed = 2.4;\n        break;\n    }\n    if (GlobalStateStore.getNumLevelsSolved() > 5) {\n      speed = 2.5;\n    }\n\n    var finishAnimationChain = null;\n    if (skipFinishAnimation) {\n      var deferred = Q.defer();\n      deferred.resolve();\n      finishAnimationChain = deferred.promise;\n      Main.getEventBaton().trigger(\n        'commandSubmitted',\n        'echo \"level solved! type in \\'levels\\' to access the next level\"'\n      );\n    } else {\n      GlobalStateActions.changeIsAnimating(true);\n      finishAnimationChain = this.mainVis.gitVisuals.finishAnimation(speed);\n      if (this.mainVis.originVis) {\n        finishAnimationChain = finishAnimationChain.then(\n          this.mainVis.originVis.gitVisuals.finishAnimation(speed)\n        );\n      }\n    }\n\n    if (!skipFinishDialog) {\n      finishAnimationChain = finishAnimationChain.then(function() {\n        // we want to ask if they will move onto the next level\n        // while giving them their results...\n        var nextDialog = new NextLevelConfirm({\n          nextLevel: nextLevel,\n          numCommands: numCommands,\n          best: best\n        });\n\n        return nextDialog.getPromise();\n      });\n    }\n\n    finishAnimationChain\n    .then(function() {\n      if (!skipFinishDialog && nextLevel) {\n        log.choseNextLevel(nextLevel.id);\n        Main.getEventBaton().trigger(\n          'commandSubmitted',\n          'level ' + nextLevel.id\n        );\n      }\n    })\n    .fail(function() {\n      // nothing to do, we will just close\n    })\n    .done(function() {\n      GlobalStateActions.changeIsAnimating(false);\n      defer.resolve();\n    });\n  },\n\n  die: function() {\n    ReactDOM.unmountComponentAtNode(\n      document.getElementById('levelToolbarMount')\n    );\n\n    this.hideGoal();\n    this.mainVis.die();\n    this.releaseControl();\n\n    this.clear();\n\n    delete this.commandCollection;\n    delete this.mainVis;\n    delete this.goalVis;\n    delete this.goalCanvasHolder;\n  },\n\n  getInstantCommands: function() {\n    var getHint = function() {\n      var hint = intl.getHint(this.level);\n      if (!hint || !hint.length) {\n        return intl.str('no-hint');\n      }\n      return hint;\n    }.bind(this);\n\n    return [\n      [/^help$|^\\?$/, function() {\n        throw new Errors.CommandResult({\n          msg: intl.str('help-vague-level')\n        });\n      }],\n      [/^hint$/, function() {\n        throw new Errors.CommandResult({\n          msg: getHint()\n        });\n      }]\n    ];\n  },\n\n  reset: function(command, deferred) {\n    this.gitCommandsIssued = [];\n\n    var commandStr = (command) ? command.get('rawStr') : '';\n    if (!this.testOptionOnString(commandStr, 'forSolution')) {\n      this.isShowingSolution = false;\n    }\n    if (this.solved) {\n      this.wasResetAfterSolved = true;\n    }\n    this.solved = false;\n    Level.__super__.reset.apply(this, arguments);\n  },\n\n  buildLevel: function(command, deferred) {\n    this.exitLevel();\n    setTimeout(function() {\n      Main.getSandbox().buildLevel(command, deferred);\n    }, this.getAnimationTime() * 1.5);\n  },\n\n  importLevel: function(command, deferred) {\n    this.exitLevel();\n    setTimeout(function() {\n      Main.getSandbox().importLevel(command, deferred);\n    }, this.getAnimationTime() * 1.5);\n  },\n\n  startLevel: function(command, deferred) {\n    this.exitLevel();\n\n    setTimeout(function() {\n      Main.getSandbox().startLevel(command, deferred);\n    }, this.getAnimationTime() * 1.5);\n    // wow! that was simple :D\n  },\n\n  exitLevel: function(command, deferred) {\n    this.die();\n\n    if (!command || !deferred) {\n      return;\n    }\n\n    setTimeout(function() {\n      command.finishWith(deferred);\n    }, this.getAnimationTime());\n\n    // we need to fade in the sandbox\n    Main.getEventBaton().trigger('levelExited');\n  },\n\n  processLevelCommand: function(command, defer) {\n    var methodMap = {\n      'show goal': this.showGoal,\n      'hide goal': this.hideGoal,\n      'show solution': this.showSolution,\n      'start dialog': this.startDialog,\n      'help level': this.startDialog,\n      'objective': this.objectiveDialog\n    };\n    var method = methodMap[command.get('method')];\n    if (!method) {\n      throw new Error('woah we don\\'t support that method yet', method);\n    }\n\n    method.apply(this, [command, defer]);\n  }\n});\n\nexports.Level = Level;\nexports.regexMap = regexMap;\n",
                        "commit": {
                            "oid": "5e6af5d3720219eaa5a00e846df03861fc81b20e"
                        }
                    },
                    "lineMatches": [
                        {
                            "preview": "      canvasHolder.die();",
                            "lineNumber": 350,
                            "offsetAndLengths": [
                                [
                                    19,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.mainVis.die();",
                            "lineNumber": 566,
                            "offsetAndLengths": [
                                [
                                    17,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.die();",
                            "lineNumber": 638,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        }
                    ]
                },
                {
                    "__typename": "FileMatch",
                    "repository": {
                        "name": "github.com/pcottle/learnGitBranching",
                        "url": "/github.com/pcottle/learnGitBranching"
                    },
                    "file": {
                        "name": "index.js",
                        "path": "src/js/views/index.js",
                        "url": "/github.com/pcottle/learnGitBranching/-/blob/src/js/views/index.js",
                        "content": "var _ = require('underscore');\nvar Q = require('q');\nvar Backbone = require('backbone');\nvar { marked } = require('marked');\n\nvar Main = require('../app');\nvar intl = require('../intl');\nvar log = require('../log');\nvar Constants = require('../util/constants');\nvar KeyboardListener = require('../util/keyboard').KeyboardListener;\nvar debounce = require('../util/debounce');\nvar throttle = require('../util/throttle');\n\nvar BaseView = Backbone.View.extend({\n  getDestination: function() {\n    return this.destination || this.container.getInsideElement();\n  },\n\n  tearDown: function() {\n    this.$el.remove();\n    if (this.container) {\n      this.container.tearDown();\n    }\n  },\n\n  renderAgain: function(HTML) {\n    // flexibility\n    HTML = HTML || this.template(this.JSON);\n    this.$el.html(HTML);\n  },\n\n  render: function(HTML) {\n    this.renderAgain(HTML);\n    var destination = this.getDestination();\n    $(destination).append(this.el);\n  }\n});\n\nvar ResolveRejectBase = BaseView.extend({\n  resolve: function() {\n    this.deferred.resolve();\n  },\n\n  reject: function() {\n    this.deferred.reject();\n  }\n});\n\nvar PositiveNegativeBase = BaseView.extend({\n  positive: function() {\n    this.navEvents.trigger('positive');\n  },\n\n  exit: function() {\n    this.navEvents.trigger('exit');\n  },\n\n  negative: function() {\n    this.navEvents.trigger('negative');\n  }\n});\n\nvar ContainedBase = BaseView.extend({\n  getAnimationTime: function() { return 700; },\n\n  show: function() {\n    this.container.show();\n  },\n\n  hide: function() {\n    this.container.hide();\n  },\n\n  die: function() {\n    this.hide();\n    setTimeout(function() {\n      this.tearDown();\n    }.bind(this), this.getAnimationTime() * 1.1);\n  }\n});\n\nvar GeneralButton = ContainedBase.extend({\n  tagName: 'a',\n  className: 'generalButton uiButton',\n  template: _.template($('#general-button').html()),\n  events: {\n    'click': 'click'\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.navEvents = options.navEvents || Object.assign({}, Backbone.Events);\n    this.destination = options.destination;\n    if (!this.destination) {\n      this.container = new ModalTerminal();\n    }\n\n    this.JSON = {\n      buttonText: options.buttonText || 'General Button',\n      wantsWrapper: (options.wantsWrapper !== undefined) ? options.wantsWrapper : true\n    };\n\n    this.render();\n\n    if (this.container && !options.wait) {\n      this.show();\n    }\n  },\n\n  click: function() {\n    if (!this.clickFunc) {\n      this.clickFunc = throttle(\n        this.sendClick.bind(this),\n        500\n      );\n    }\n    this.clickFunc();\n  },\n\n  sendClick: function() {\n    this.navEvents.trigger('click');\n  }.bind(this)\n});\n\nvar ConfirmCancelView = ResolveRejectBase.extend({\n  tagName: 'div',\n  className: 'confirmCancelView box horizontal justify',\n  template: _.template($('#confirm-cancel-template').html()),\n  events: {\n    'click .confirmButton': 'resolve',\n    'click .cancelButton': 'reject'\n  },\n\n  initialize: function(options) {\n    if (!options.destination) {\n      throw new Error('needmore');\n    }\n\n    this.destination = options.destination;\n    this.deferred = options.deferred || Q.defer();\n    this.JSON = {\n      confirm: options.confirm || intl.str('confirm-button'),\n      cancel: options.cancel || intl.str('cancel-button')\n    };\n\n    this.render();\n  }\n});\n\nvar LeftRightView = PositiveNegativeBase.extend({\n  tagName: 'div',\n  className: 'leftRightView box horizontal center',\n  template: _.template($('#left-right-template').html()),\n\n  initialize: function(options) {\n    if (!options.destination || !options.events) {\n      throw new Error('needmore');\n    }\n\n    this.destination = options.destination;\n\n    // we switch to a system where every leftrightview has its own\n    // events system to add support for git demonstration view taking control of the\n    // click events\n    this.pipeEvents = options.events;\n    this.navEvents = Object.assign({}, Backbone.Events);\n\n    this.JSON = {\n      showLeft: (options.showLeft === undefined) ? true : options.showLeft,\n      lastNav: (options.lastNav === undefined) ? false : options.lastNav\n    };\n\n    this.render();\n    // For some weird reason backbone events aren't working anymore so\n    // im going to just wire this up manually\n    this.$('div.right').click(this.positive.bind(this));\n    this.$('div.left').click(this.negative.bind(this));\n    this.$('div.exit').click(this.exit.bind(this));\n  },\n\n  exit: function() {\n    this.pipeEvents.trigger('exit');\n    LeftRightView.__super__.exit.apply(this);\n  },\n\n  positive: function() {\n    this.pipeEvents.trigger('positive');\n    LeftRightView.__super__.positive.apply(this);\n  },\n\n  negative: function() {\n    this.pipeEvents.trigger('negative');\n    LeftRightView.__super__.negative.apply(this);\n  }\n\n});\n\nvar ModalView = Backbone.View.extend({\n  tagName: 'div',\n  className: 'modalView box horizontal center transitionOpacityLinear',\n  template: _.template($('#modal-view-template').html()),\n\n  getAnimationTime: function() { return 700; },\n\n  initialize: function(options) {\n    this.shown = false;\n    this.render();\n  },\n\n  render: function() {\n    // add ourselves to the DOM\n    this.$el.html(this.template({}));\n    $('body').append(this.el);\n    // this doesn't necessarily show us though...\n  },\n\n  stealKeyboard: function() {\n    Main.getEventBaton().stealBaton('keydown', this.onKeyDown, this);\n    Main.getEventBaton().stealBaton('keyup', this.onKeyUp, this);\n    Main.getEventBaton().stealBaton('windowFocus', this.onWindowFocus, this);\n    Main.getEventBaton().stealBaton('documentClick', this.onDocumentClick, this);\n\n    // blur the text input field so keydown events will not be caught by our\n    // preventDefaulters, allowing people to still refresh and launch inspector (etc)\n    $('#commandTextField').blur();\n  },\n\n  releaseKeyboard: function() {\n    Main.getEventBaton().releaseBaton('keydown', this.onKeyDown, this);\n    Main.getEventBaton().releaseBaton('keyup', this.onKeyUp, this);\n    Main.getEventBaton().releaseBaton('windowFocus', this.onWindowFocus, this);\n    Main.getEventBaton().releaseBaton('documentClick', this.onDocumentClick, this);\n\n    Main.getEventBaton().trigger('windowFocus');\n  },\n\n  onWindowFocus: function(e) {\n    //console.log('window focus doing nothing', e);\n  },\n\n  onDocumentClick: function(e) {\n    //console.log('doc click doing nothing', e);\n  },\n\n  onKeyDown: function(e) {\n    e.preventDefault();\n  },\n\n  onKeyUp: function(e) {\n    e.preventDefault();\n  },\n\n  show: function() {\n    this.toggleZ(true);\n    // on reflow, change our class to animate. for whatever\n    // reason if this is done immediately, chrome might combine\n    // the two changes and lose the ability to animate and it looks bad.\n    process.nextTick(function() {\n      this.toggleShow(true);\n    }.bind(this));\n  },\n\n  hide: function() {\n    this.toggleShow(false);\n    setTimeout(function() {\n      // if we are still hidden...\n      if (!this.shown) {\n        this.toggleZ(false);\n      }\n    }.bind(this), this.getAnimationTime());\n  },\n\n  getInsideElement: function() {\n    return this.$('.contentHolder');\n  },\n\n  toggleShow: function(value) {\n    // this prevents releasing keyboard twice\n    if (this.shown === value) { return; }\n\n    if (value) {\n      this.stealKeyboard();\n    } else {\n      this.releaseKeyboard();\n    }\n\n    this.shown = value;\n    this.$el.toggleClass('show', value);\n  },\n\n  toggleZ: function(value) {\n    this.$el.toggleClass('inFront', value);\n  },\n\n  tearDown: function() {\n    this.$el.html('');\n    $('body')[0].removeChild(this.el);\n  }\n});\n\nvar ModalTerminal = ContainedBase.extend({\n  tagName: 'div',\n  className: 'modalTerminal box flex1',\n  template: _.template($('#terminal-window-template').html()),\n  events: {\n    'click div.inside': 'onClick'\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.navEvents = options.events || Object.assign({}, Backbone.Events);\n\n    this.container = new ModalView();\n    this.JSON = {\n      title: options.title\n    };\n\n    this.render();\n  },\n\n  updateTitle: function(/*string*/ title) {\n    this.$('.modal-title').text(title);\n  },\n\n  onClick: function() {\n    this.navEvents.trigger('click');\n  },\n\n  getInsideElement: function() {\n    return this.$('.inside');\n  }\n});\n\nvar ModalAlert = ContainedBase.extend({\n  tagName: 'div',\n  template: _.template($('#modal-alert-template').html()),\n\n  initialize: function(options) {\n    this.options = options || {};\n    this.JSON = {\n      title: options.title || 'Something to say',\n      text: options.text || 'Here is a paragraph',\n      markdown: options.markdown\n    };\n\n    if (options.markdowns) {\n      this.JSON.markdown = options.markdowns.join('\\n');\n    }\n\n    this.container = new ModalTerminal({});\n    this.render();\n\n    if (!options.wait) {\n      this.show();\n    }\n  },\n\n  render: function() {\n    var HTML = (this.JSON.markdown) ?\n      marked(this.JSON.markdown) :\n      this.template(this.JSON);\n    // one more hack -- allow adding custom random HTML if specified\n    if (this.options._dangerouslyInsertHTML) {\n      HTML += this.options._dangerouslyInsertHTML;\n    }\n\n    // call to super, not super elegant but better than\n    // copy paste code\n    ModalAlert.__super__.render.apply(this, [HTML]);\n  }\n});\n\nvar ConfirmCancelTerminal = Backbone.View.extend({\n  initialize: function(options) {\n    options = options || {};\n\n    this.deferred = options.deferred || Q.defer();\n    this.modalAlert = new ModalAlert(Object.assign(\n      {},\n      { markdown: '#you sure?' },\n      options\n    ));\n\n    var buttonDefer = Q.defer();\n    this.buttonDefer = buttonDefer;\n    this.confirmCancel = new ConfirmCancelView({\n      deferred: buttonDefer,\n      destination: this.modalAlert.getDestination()\n    });\n\n    // whenever they hit a button. make sure\n    // we close and pass that to our deferred\n    buttonDefer.promise\n    .then(this.deferred.resolve)\n    .fail(this.deferred.reject)\n    .done(function() {\n      this.close();\n    }.bind(this));\n\n    // also setup keyboard\n    this.navEvents = Object.assign({}, Backbone.Events);\n    this.navEvents.on('positive', this.positive, this);\n    this.navEvents.on('negative', this.negative, this);\n    this.keyboardListener = new KeyboardListener({\n      events: this.navEvents,\n      aliasMap: {\n        enter: 'positive',\n        esc: 'negative'\n      }\n    });\n\n    if (!options.wait) {\n      this.modalAlert.show();\n    }\n  },\n\n  positive: function() {\n    this.buttonDefer.resolve();\n  },\n\n  negative: function() {\n    this.buttonDefer.reject();\n  },\n\n  getAnimationTime: function() { return 700; },\n\n  show: function() {\n    this.modalAlert.show();\n  },\n\n  hide: function() {\n    this.modalAlert.hide();\n  },\n\n  getPromise: function() {\n    return this.deferred.promise;\n  },\n\n  close: function() {\n    this.keyboardListener.mute();\n    this.modalAlert.die();\n  }\n});\n\nvar NextLevelConfirm = ConfirmCancelTerminal.extend({\n  initialize: function(options) {\n    options = options || {};\n    var nextLevelName = (options.nextLevel) ?\n      intl.getName(options.nextLevel) :\n      '';\n\n    // lol hax\n    var markdowns = intl.getDialog(require('../dialogs/nextLevel'))[0].options.markdowns;\n    var markdown = markdowns.join('\\n');\n    markdown = intl.template(markdown, {\n      numCommands: options.numCommands,\n      best: options.best\n    });\n\n    if (options.numCommands <= options.best) {\n      markdown = markdown + '\\n\\n' + intl.str('finish-dialog-win');\n    } else {\n      markdown = markdown + '\\n\\n' + intl.str('finish-dialog-lose', {best: options.best});\n    }\n\n    markdown = markdown + '\\n\\n';\n    var extraHTML;\n    if (options.nextLevel) {\n      markdown = markdown + intl.str('finish-dialog-next', {nextLevel: nextLevelName});\n    } else {\n      extraHTML = '<p class=\"catchadream\">' + intl.str('finish-dialog-finished') +\n        ' (ﾉ^_^)ﾉ (ﾉ^_^)ﾉ (ﾉ^_^)ﾉ' +\n        '</p>';\n    }\n\n    options = Object.assign(\n      {},\n      options,\n      {\n        markdown: markdown,\n        _dangerouslyInsertHTML: extraHTML\n      }\n    );\n\n    NextLevelConfirm.__super__.initialize.apply(this, [options]);\n  }\n});\n\nvar ViewportAlert = Backbone.View.extend({\n  initialize: function(options) {\n    this.grabBatons();\n    this.modalAlert = new ModalAlert({\n      markdowns: this.markdowns\n    });\n    this.modalAlert.show();\n  },\n\n  grabBatons: function() {\n    Main.getEventBaton().stealBaton(this.eventBatonName, this.batonFired, this);\n  },\n\n  releaseBatons: function() {\n    Main.getEventBaton().releaseBaton(this.eventBatonName, this.batonFired, this);\n  },\n\n  finish: function() {\n    this.releaseBatons();\n    this.modalAlert.die();\n  }\n});\n\nvar WindowSizeAlertWindow = ViewportAlert.extend({\n  initialize: function(options) {\n    this.eventBatonName = 'windowSizeCheck';\n    this.markdowns = [\n      '## That window size is not supported :-/',\n      'Please resize your window back to a supported size',\n      '',\n      '(and of course, pull requests to fix this are appreciated :D)'\n    ];\n    WindowSizeAlertWindow.__super__.initialize.apply(this, [options]);\n  },\n\n  batonFired: function(size) {\n    if (size.w > Constants.VIEWPORT.minWidth &&\n        size.h > Constants.VIEWPORT.minHeight) {\n      this.finish();\n    }\n  }\n});\n\nvar ZoomAlertWindow = ViewportAlert.extend({\n  initialize: function(options) {\n    if (!options || !options.level) { throw new Error('need level'); }\n\n    this.eventBatonName = 'zoomChange';\n    this.markdowns = [\n      '## That zoom level of ' + options.level + ' is not supported :-/',\n      'Please zoom back to a supported zoom level with Ctrl + and Ctrl -',\n      '',\n      '(and of course, pull requests to fix this are appreciated :D)'\n    ];\n    ZoomAlertWindow.__super__.initialize.apply(this, [options]);\n  },\n\n  batonFired: function(level) {\n    if (level <= Constants.VIEWPORT.maxZoom &&\n        level >= Constants.VIEWPORT.minZoom) {\n      this.finish();\n    }\n  }\n});\n\nvar CanvasTerminalHolder = BaseView.extend({\n  tagName: 'div',\n  className: 'canvasTerminalHolder box flex1',\n  template: _.template($('#terminal-window-bare-template').html()),\n  events: {\n    'click div.wrapper': 'onClick'\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.parent = options.parent;\n    this.minHeight = options.minHeight || 200;\n    this.destination = $('body');\n    this.JSON = {\n      title: options.title || intl.str('goal-to-reach'),\n      text: options.text || intl.str('hide-goal')\n    };\n\n    this.render();\n    this.inDom = true;\n\n    this.$terminal = this.$el.find('.terminal-window-holder').first();\n    this.$terminal.height(0.8 * $(window).height());\n    this.$terminal.draggable({\n      cursor: 'move',\n      handle: '.toolbar',\n      containment: '#interfaceWrapper',\n      scroll: false\n    });\n\n    // If the entire window gets resized such that the terminal is outside the view, then\n    // move it back into the view, and expand/shrink it vertically as necessary.\n    $(window).on('resize', debounce(this.recalcLayout.bind(this), 300));\n\n    if (options.additionalClass) {\n      this.$el.addClass(options.additionalClass);\n    }\n  },\n\n  getAnimationTime: function() { return 700; },\n\n  onClick: function() {\n    this.die();\n  },\n\n  die: function() {\n    this.minimize();\n    this.inDom = false;\n\n    setTimeout(function() {\n      this.tearDown();\n    }.bind(this), this.getAnimationTime());\n  },\n\n  minimize: function() {\n    this.parent.trigger('minimizeCanvas', {\n      left: this.$terminal.css('left'),\n      top: this.$terminal.css('top')\n    }, {\n      width: this.$terminal.css('width'),\n      height: this.$terminal.css('height')\n    });\n\n    this.$terminal.animate({\n      height: '0px',\n      opacity: 0\n    }, this.getAnimationTime());\n  },\n\n  restore: function (pos, size) {\n    var self = this;\n    pos = pos || { top: this.$terminal.css('top'), left: this.$terminal.css('left') };\n    size = size || { width: this.$terminal.css('width'), height: this.$terminal.css('height') };\n\n    this.$terminal.css({\n      top: pos.top,\n      left: pos.left,\n      width: size.width,\n      height: '0px',\n      opacity: '0'\n    });\n\n    this.$terminal.animate({\n      height: size.height,\n      opacity: 1\n    }, this.getAnimationTime(), function() {\n        self.recalcLayout();\n    });\n  },\n\n  recalcLayout: function () {\n    // Resize/reposition self based on the size of the browser window.\n\n    var parent = this.parent,\n        leftOffset = 0,\n        topOffset = 0,\n        heightOffset = 0,\n        width = this.$terminal.outerWidth(),\n        height = this.$terminal.outerHeight(),\n        left = this.$terminal.offset().left,\n        top = this.$terminal.offset().top,\n        right = ($(window).width() - (left + width)),\n        bottom = ($(window).height() - (top + height)),\n        minHeight = 0.75 * $(window).height(),\n        maxHeight = 0.95 * $(window).height();\n\n    // Calculate offsets\n    if (top < 0) { topOffset = -top; }\n    if (left < 0) { leftOffset = -left; }\n    if (right < 0) { leftOffset = right; }\n    if (bottom < 0) { topOffset = bottom; }\n    if (height < minHeight) { heightOffset = minHeight - height; }\n    if (height > maxHeight) { heightOffset = maxHeight - height; }\n\n    // Establish limits\n    left = Math.max(left + leftOffset, 0);\n    top = Math.max(top + topOffset, 0);\n    height = Math.max(height + heightOffset, minHeight);\n\n    // Set the new position/size\n    this.$terminal.animate({\n      left: left + 'px',\n      top: top + 'px',\n      height: height + 'px'\n    }, this.getAnimationTime(), function () {\n        parent.trigger('resizeCanvas');\n    });\n  },\n\n  getCanvasLocation: function() {\n    return this.$('div.inside')[0];\n  }\n});\n\nexports.BaseView = BaseView;\nexports.GeneralButton = GeneralButton;\nexports.ModalView = ModalView;\nexports.ModalTerminal = ModalTerminal;\nexports.ModalAlert = ModalAlert;\nexports.ContainedBase = ContainedBase;\nexports.ConfirmCancelView = ConfirmCancelView;\nexports.LeftRightView = LeftRightView;\nexports.ZoomAlertWindow = ZoomAlertWindow;\nexports.ConfirmCancelTerminal = ConfirmCancelTerminal;\nexports.WindowSizeAlertWindow = WindowSizeAlertWindow;\n\nexports.CanvasTerminalHolder = CanvasTerminalHolder;\nexports.NextLevelConfirm = NextLevelConfirm;\n",
                        "commit": {
                            "oid": "5e6af5d3720219eaa5a00e846df03861fc81b20e"
                        }
                    },
                    "lineMatches": [
                        {
                            "preview": "    this.modalAlert.die();",
                            "lineNumber": 440,
                            "offsetAndLengths": [
                                [
                                    20,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.modalAlert.die();",
                            "lineNumber": 507,
                            "offsetAndLengths": [
                                [
                                    20,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.die();",
                            "lineNumber": 595,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        }
                    ]
                },
                {
                    "__typename": "FileMatch",
                    "repository": {
                        "name": "github.com/pcottle/learnGitBranching",
                        "url": "/github.com/pcottle/learnGitBranching"
                    },
                    "file": {
                        "name": "builderViews.js",
                        "path": "src/js/views/builderViews.js",
                        "url": "/github.com/pcottle/learnGitBranching/-/blob/src/js/views/builderViews.js",
                        "content": "var _ = require('underscore');\nvar Q = require('q');\nvar { marked } = require('marked');\n\nvar Views = require('../views');\nvar throttle = require('../util/throttle');\nvar ModalTerminal = Views.ModalTerminal;\nvar ContainedBase = Views.ContainedBase;\n\nvar TextGrabber = ContainedBase.extend({\n  tagName: 'div',\n  className: 'textGrabber box vertical',\n  template: _.template($('#text-grabber').html()),\n\n  initialize: function(options) {\n    options = options || {};\n    this.JSON = {\n      helperText: options.helperText || 'Enter some text'\n    };\n\n    this.container = options.container || new ModalTerminal({\n      title: 'Enter some text'\n    });\n    this.render();\n    if (options.initialText) {\n      this.setText(options.initialText);\n    }\n\n    if (!options.wait) {\n      this.show();\n    }\n  },\n\n  getText: function() {\n    return this.$('textarea').val();\n  },\n\n  setText: function(str) {\n    this.$('textarea').val(str);\n  }\n});\n\nvar MarkdownGrabber = ContainedBase.extend({\n  tagName: 'div',\n  className: 'markdownGrabber box horizontal',\n  template: _.template($('#markdown-grabber-view').html()),\n  events: {\n    'keyup textarea': 'keyup'\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.deferred = options.deferred || Q.defer();\n\n    if (options.fromObj) {\n      options.fillerText = options.fromObj.options.markdowns.join('\\n');\n    }\n\n    this.JSON = {\n      previewText: options.previewText || 'Preview',\n      fillerText: options.fillerText || '## Enter some markdown!\\n\\n\\n'\n    };\n\n    this.container = options.container || new ModalTerminal({\n      title: options.title || 'Enter some markdown'\n    });\n    this.render();\n\n    if (!options.withoutButton) {\n      // do button stuff\n      var buttonDefer = Q.defer();\n      buttonDefer.promise\n      .then(this.confirmed.bind(this))\n      .fail(this.cancelled.bind(this))\n      .done();\n\n      var confirmCancel = new Views.ConfirmCancelView({\n        deferred: buttonDefer,\n        destination: this.getDestination()\n      });\n    }\n\n    this.updatePreview();\n\n    if (!options.wait) {\n      this.show();\n    }\n  },\n\n  confirmed: function() {\n    this.die();\n    this.deferred.resolve(this.getRawText());\n  },\n\n  cancelled: function() {\n    this.die();\n    this.deferred.resolve();\n  },\n\n  keyup: function() {\n    if (!this.throttledPreview) {\n      this.throttledPreview = throttle(\n        this.updatePreview.bind(this),\n        500\n      );\n    }\n    this.throttledPreview();\n  },\n\n  getRawText: function() {\n    return this.$('textarea').val();\n  },\n\n  exportToArray: function() {\n    return this.getRawText().split('\\n');\n  },\n\n  getExportObj: function() {\n    return {\n      markdowns: this.exportToArray()\n    };\n  },\n\n  updatePreview: function() {\n    var raw = this.getRawText();\n    var HTML = marked(raw);\n    this.$('div.insidePreview').html(HTML);\n  }\n});\n\nvar MarkdownPresenter = ContainedBase.extend({\n  tagName: 'div',\n  className: 'markdownPresenter box vertical',\n  template: _.template($('#markdown-presenter').html()),\n\n  initialize: function(options) {\n    options = options || {};\n    this.deferred = options.deferred || Q.defer();\n    this.JSON = {\n      previewText: options.previewText || 'Here is something for you',\n      fillerText: options.fillerText || '# Yay'\n    };\n\n    this.container = new ModalTerminal({\n      title: 'Check this out...'\n    });\n    this.render();\n\n    if (!options.noConfirmCancel) {\n      var confirmCancel = new Views.ConfirmCancelView({\n        destination: this.getDestination()\n      });\n      confirmCancel.deferred.promise\n      .then(function() {\n        this.deferred.resolve(this.grabText());\n      }.bind(this))\n      .fail(function() {\n        this.deferred.reject();\n      }.bind(this))\n      .done(this.die.bind(this));\n    }\n\n    this.show();\n  },\n\n  grabText: function() {\n    return this.$('textarea').val();\n  }\n});\n\nvar DemonstrationBuilder = ContainedBase.extend({\n  tagName: 'div',\n  className: 'demonstrationBuilder box vertical',\n  template: _.template($('#demonstration-builder').html()),\n  events: {\n    'click div.testButton': 'testView'\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.deferred = options.deferred || Q.defer();\n    if (options.fromObj) {\n      var toEdit = options.fromObj.options;\n      options = Object.assign(\n        {},\n        options,\n        toEdit,\n        {\n          beforeMarkdown: toEdit.beforeMarkdowns.join('\\n'),\n          afterMarkdown: toEdit.afterMarkdowns.join('\\n')\n        }\n      );\n    }\n\n    this.JSON = {};\n    this.container = new ModalTerminal({\n      title: 'Demonstration Builder'\n    });\n    this.render();\n\n    // build the two markdown grabbers\n    this.beforeMarkdownView = new MarkdownGrabber({\n      container: this,\n      withoutButton: true,\n      fillerText: options.beforeMarkdown,\n      previewText: 'Before demonstration Markdown'\n    });\n    this.beforeCommandView = new TextGrabber({\n      container: this,\n      helperText: 'The git command(s) to set up the demonstration view (before it is displayed)',\n      initialText: options.beforeCommand || 'git checkout -b bugFix'\n    });\n\n    this.commandView = new TextGrabber({\n      container: this,\n      helperText: 'The git command(s) to demonstrate to the reader',\n      initialText: options.command || 'git commit'\n    });\n\n    this.afterMarkdownView = new MarkdownGrabber({\n      container: this,\n      withoutButton: true,\n      fillerText: options.afterMarkdown,\n      previewText: 'After demonstration Markdown'\n    });\n\n    // build confirm button\n    var buttonDeferred = Q.defer();\n    var confirmCancel = new Views.ConfirmCancelView({\n      deferred: buttonDeferred,\n      destination: this.getDestination()\n    });\n\n    buttonDeferred.promise\n    .then(this.confirmed.bind(this))\n    .fail(this.cancelled.bind(this))\n    .done();\n  },\n\n  testView: function() {\n    var MultiView = require('../views/multiView').MultiView;\n    new MultiView({\n      childViews: [{\n        type: 'GitDemonstrationView',\n        options: this.getExportObj()\n      }]\n    });\n  },\n\n  getExportObj: function() {\n    return {\n      beforeMarkdowns: this.beforeMarkdownView.exportToArray(),\n      afterMarkdowns: this.afterMarkdownView.exportToArray(),\n      command: this.commandView.getText(),\n      beforeCommand: this.beforeCommandView.getText()\n    };\n  },\n\n  confirmed: function() {\n    this.die();\n    this.deferred.resolve(this.getExportObj());\n  },\n\n  cancelled: function() {\n    this.die();\n    this.deferred.resolve();\n  },\n\n  getInsideElement: function() {\n    return this.$('.insideBuilder')[0];\n  }\n});\n\nvar MultiViewBuilder = ContainedBase.extend({\n  tagName: 'div',\n  className: 'multiViewBuilder box vertical',\n  template: _.template($('#multi-view-builder').html()),\n  typeToConstructor: {\n    ModalAlert: MarkdownGrabber,\n    GitDemonstrationView: DemonstrationBuilder\n  },\n\n  events: {\n    'click div.deleteButton': 'deleteOneView',\n    'click div.testButton': 'testOneView',\n    'click div.editButton': 'editOneView',\n    'click div.testEntireView': 'testEntireView',\n    'click div.addView': 'addView',\n    'click div.saveView': 'saveView',\n    'click div.cancelView': 'cancel'\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.deferred = options.deferred || Q.defer();\n    this.multiViewJSON = options.multiViewJSON || {};\n\n    this.JSON = {\n      views: this.getChildViews(),\n      supportedViews: Object.keys(this.typeToConstructor)\n    };\n\n    this.container = new ModalTerminal({\n      title: 'Build a MultiView!'\n    });\n    this.render();\n\n    this.show();\n  },\n\n  saveView: function() {\n    this.hide();\n    this.deferred.resolve(this.multiViewJSON);\n  },\n\n  cancel: function() {\n    this.hide();\n    this.deferred.resolve();\n  },\n\n  addView: function(ev) {\n    var el = ev.target;\n    var type = $(el).attr('data-type');\n\n    var whenDone = Q.defer();\n    var Constructor = this.typeToConstructor[type];\n    var builder = new Constructor({\n      deferred: whenDone\n    });\n    whenDone.promise\n    .then(function() {\n      var newView = {\n        type: type,\n        options: builder.getExportObj()\n      };\n      this.addChildViewObj(newView);\n    }.bind(this))\n    .fail(function() {\n      // they don't want to add the view apparently, so just return\n    })\n    .done();\n  },\n\n  testOneView: function(ev) {\n    var el = ev.target;\n    var index = $(el).attr('data-index');\n    var toTest = this.getChildViews()[index];\n    var MultiView = require('../views/multiView').MultiView;\n    new MultiView({\n      childViews: [toTest]\n    });\n  },\n\n  testEntireView: function() {\n    var MultiView = require('../views/multiView').MultiView;\n    new MultiView({\n      childViews: this.getChildViews()\n    });\n  },\n\n  editOneView: function(ev) {\n    var el = ev.target;\n    var index = $(el).attr('data-index');\n    var type = $(el).attr('data-type');\n\n    var whenDone = Q.defer();\n    var builder = new this.typeToConstructor[type]({\n      deferred: whenDone,\n      fromObj: this.getChildViews()[index]\n    });\n    whenDone.promise\n    .then(function() {\n      var newView = {\n        type: type,\n        options: builder.getExportObj()\n      };\n      var views = this.getChildViews();\n      views[index] = newView;\n      this.setChildViews(views);\n    }.bind(this))\n    .fail(function() { })\n    .done();\n  },\n\n  deleteOneView: function(ev) {\n    var el = ev.target;\n    var index = $(el).attr('data-index');\n    var toSlice = this.getChildViews();\n\n    var updated = toSlice.slice(0,index).concat(toSlice.slice(index + 1));\n    this.setChildViews(updated);\n    this.update();\n  },\n\n  addChildViewObj: function(newObj, index) {\n    var childViews = this.getChildViews();\n    childViews.push(newObj);\n    this.setChildViews(childViews);\n    this.update();\n  },\n\n  setChildViews: function(newArray) {\n    this.multiViewJSON.childViews = newArray;\n  },\n\n  getChildViews: function() {\n    return this.multiViewJSON.childViews || [];\n  },\n\n  update: function() {\n    this.JSON.views = this.getChildViews();\n    this.renderAgain();\n  }\n});\n\nexports.MarkdownGrabber = MarkdownGrabber;\nexports.DemonstrationBuilder = DemonstrationBuilder;\nexports.TextGrabber = TextGrabber;\nexports.MultiViewBuilder = MultiViewBuilder;\nexports.MarkdownPresenter = MarkdownPresenter;\n",
                        "commit": {
                            "oid": "5e6af5d3720219eaa5a00e846df03861fc81b20e"
                        }
                    },
                    "lineMatches": [
                        {
                            "preview": "    this.die();",
                            "lineNumber": 90,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.die();",
                            "lineNumber": 95,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.die();",
                            "lineNumber": 259,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        },
                        {
                            "preview": "    this.die();",
                            "lineNumber": 264,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        }
                    ]
                },
                {
                    "__typename": "FileMatch",
                    "repository": {
                        "name": "github.com/pcottle/learnGitBranching",
                        "url": "/github.com/pcottle/learnGitBranching"
                    },
                    "file": {
                        "name": "rebaseView.js",
                        "path": "src/js/views/rebaseView.js",
                        "url": "/github.com/pcottle/learnGitBranching/-/blob/src/js/views/rebaseView.js",
                        "content": "var GitError = require('../util/errors').GitError;\nvar _ = require('underscore');\nvar Q = require('q');\nvar Backbone = require('backbone');\n\nvar ModalTerminal = require('../views').ModalTerminal;\nvar ContainedBase = require('../views').ContainedBase;\nvar ConfirmCancelView = require('../views').ConfirmCancelView;\n\nvar intl = require('../intl');\n\nrequire('jquery-ui/ui/widget');\nrequire('jquery-ui/ui/scroll-parent');\nrequire('jquery-ui/ui/data');\nrequire('jquery-ui/ui/widgets/mouse');\nrequire('jquery-ui/ui/ie');\nrequire('jquery-ui/ui/widgets/sortable');\nrequire('jquery-ui/ui/plugin');\nrequire('jquery-ui/ui/safe-active-element');\nrequire('jquery-ui/ui/safe-blur');\nrequire('jquery-ui/ui/widgets/draggable');\n\nvar InteractiveRebaseView = ContainedBase.extend({\n  tagName: 'div',\n  template: _.template($('#interactive-rebase-template').html()),\n\n  initialize: function(options) {\n    this.deferred = options.deferred;\n    this.rebaseMap = {};\n    this.entryObjMap = {};\n    this.options = options;\n\n    this.rebaseEntries = new RebaseEntryCollection();\n    options.toRebase.reverse();\n    options.toRebase.forEach(function(commit) {\n      var id = commit.get('id');\n      this.rebaseMap[id] = commit;\n\n      // make basic models for each commit\n      this.entryObjMap[id] = new RebaseEntry({\n        id: id\n      });\n      this.rebaseEntries.add(this.entryObjMap[id]);\n    }, this);\n\n    this.container = new ModalTerminal({\n      title: intl.str('interactive-rebase-title')\n    });\n    this.render();\n\n    // show the dialog holder\n    this.show();\n\n    if (options.aboveAll) {\n      // TODO fix this :(\n      $('#canvasHolder').css('display', 'none');\n    }\n  },\n\n  restoreVis: function() {\n    // restore the absolute position canvases\n    $('#canvasHolder').css('display', 'inherit');\n  },\n\n  confirm: function() {\n    this.die();\n    if (this.options.aboveAll) {\n      this.restoreVis();\n    }\n\n    // get our ordering\n    var uiOrder = [];\n    this.$('ul.rebaseEntries li').each(function(i, obj) {\n      uiOrder.push(obj.id);\n    });\n\n    // now get the real array\n    var toRebase = [];\n    uiOrder.forEach(function(id) {\n      // the model pick check\n      if (this.entryObjMap[id].get('pick')) {\n        toRebase.unshift(this.rebaseMap[id]);\n      }\n    }, this);\n    toRebase.reverse();\n\n    this.deferred.resolve(toRebase);\n    // garbage collection will get us\n    this.$el.html('');\n  },\n\n  render: function() {\n    var json = {\n      num: Object.keys(this.rebaseMap).length,\n      solutionOrder: this.options.initialCommitOrdering\n    };\n\n    var destination = this.container.getInsideElement();\n    this.$el.html(this.template(json));\n    $(destination).append(this.el);\n\n    // also render each entry\n    var listHolder = this.$('ul.rebaseEntries');\n    this.rebaseEntries.each(function(entry) {\n      new RebaseEntryView({\n        el: listHolder,\n        model: entry\n      });\n    }, this);\n\n    // then make it reorderable..\n    listHolder.sortable({\n      axis: 'y',\n      placeholder: 'rebaseEntry transitionOpacity ui-state-highlight',\n      appendTo: 'parent'\n    });\n\n    this.makeButtons();\n  },\n\n  cancel: function() {\n    // empty array does nothing, just like in git\n    this.hide();\n    if (this.options.aboveAll) {\n      this.restoreVis();\n    }\n    this.deferred.resolve([]);\n  },\n\n  makeButtons: function() {\n    // control for button\n    var deferred = Q.defer();\n    deferred.promise\n    .then(function() {\n      this.confirm();\n    }.bind(this))\n    .fail(function() {\n      this.cancel();\n    }.bind(this))\n    .done();\n\n    // finally get our buttons\n    new ConfirmCancelView({\n      destination: this.$('.confirmCancel'),\n      deferred: deferred\n    });\n  }\n});\n\nvar RebaseEntry = Backbone.Model.extend({\n  defaults: {\n    pick: true\n  },\n\n  toggle: function() {\n    this.set('pick', !this.get('pick'));\n  }\n});\n\nvar RebaseEntryCollection = Backbone.Collection.extend({\n  model: RebaseEntry\n});\n\nvar RebaseEntryView = Backbone.View.extend({\n  tagName: 'li',\n  template: _.template($('#interactive-rebase-entry-template').html()),\n\n  toggle: function() {\n    this.model.toggle();\n\n    // toggle a class also\n    this.listEntry.toggleClass('notPicked', !this.model.get('pick'));\n  },\n\n  initialize: function(options) {\n    this.render();\n  },\n\n  render: function() {\n    this.$el.append(this.template(this.model.toJSON()));\n\n    // hacky :( who would have known jquery barfs on ids with %'s and quotes\n    this.listEntry = this.$el.children(':last');\n\n    this.listEntry.delegate('#toggleButton', 'click', function() {\n      this.toggle();\n    }.bind(this));\n  }\n});\n\nexports.InteractiveRebaseView = InteractiveRebaseView;\n",
                        "commit": {
                            "oid": "5e6af5d3720219eaa5a00e846df03861fc81b20e"
                        }
                    },
                    "lineMatches": [
                        {
                            "preview": "    this.die();",
                            "lineNumber": 65,
                            "offsetAndLengths": [
                                [
                                    9,
                                    5
                                ]
                            ],
                            "limitHit": false
                        }
                    ]
                },
                {
                    "__typename": "FileMatch",
                    "repository": {
                        "name": "github.com/pcottle/learnGitBranching",
                        "url": "/github.com/pcottle/learnGitBranching"
                    },
                    "file": {
                        "name": "multiView.js",
                        "path": "src/js/views/multiView.js",
                        "url": "/github.com/pcottle/learnGitBranching/-/blob/src/js/views/multiView.js",
                        "content": "var Q = require('q');\nvar Backbone = require('backbone');\n\nvar LeftRightView = require('../views').LeftRightView;\nvar ModalAlert = require('../views').ModalAlert;\nvar GitDemonstrationView = require('../views/gitDemonstrationView').GitDemonstrationView;\n\nvar BuilderViews = require('../views/builderViews');\nvar MarkdownPresenter = BuilderViews.MarkdownPresenter;\n\nvar KeyboardListener = require('../util/keyboard').KeyboardListener;\nvar debounce = require('../util/debounce');\n\nvar MultiView = Backbone.View.extend({\n  tagName: 'div',\n  className: 'multiView',\n  // ms to debounce the nav functions\n  navEventDebounce: 550,\n  deathTime: 700,\n\n  // a simple mapping of what childViews we support\n  typeToConstructor: {\n    ModalAlert: ModalAlert,\n    GitDemonstrationView: GitDemonstrationView,\n    MarkdownPresenter: MarkdownPresenter\n  },\n\n  initialize: function(options) {\n    options = options || {};\n    this.childViewJSONs = options.childViews || [{\n      type: 'ModalAlert',\n      options: {\n        markdown: 'Woah wtf!!'\n      }\n     }, {\n       type: 'GitDemonstrationView',\n       options: {\n         command: 'git checkout -b side; git commit; git commit'\n       }\n     }, {\n      type: 'ModalAlert',\n      options: {\n        markdown: 'Im second'\n      }\n    }];\n    this.deferred = options.deferred || Q.defer();\n\n    this.childViews = [];\n    this.currentIndex = 0;\n\n    this.navEvents = Object.assign({}, Backbone.Events);\n    this.navEvents.on('negative', this.getNegFunc(), this);\n    this.navEvents.on('positive', this.getPosFunc(), this);\n    this.navEvents.on('quit', this.finish, this);\n    this.navEvents.on('exit', this.finish, this);\n\n    this.keyboardListener = new KeyboardListener({\n      events: this.navEvents,\n      aliasMap: {\n        left: 'negative',\n        right: 'positive',\n        enter: 'positive',\n        esc: 'quit'\n      }\n    });\n\n    this.render();\n    if (!options.wait) {\n      this.start();\n    }\n  },\n\n  onWindowFocus: function() {\n    // nothing here for now...\n    // TODO -- add a cool glow effect?\n  },\n\n  getAnimationTime: function() {\n    return 700;\n  },\n\n  getPromise: function() {\n    return this.deferred.promise;\n  },\n\n  getPosFunc: function() {\n    return debounce(function() {\n      this.navForward();\n    }.bind(this), this.navEventDebounce, true);\n  },\n\n  getNegFunc: function() {\n    return debounce(function() {\n      this.navBackward();\n    }.bind(this), this.navEventDebounce, true);\n  },\n\n  lock: function() {\n    this.locked = true;\n  },\n\n  unlock: function() {\n    this.locked = false;\n  },\n\n  navForward: function() {\n    // we need to prevent nav changes when a git demonstration view hasnt finished\n    if (this.locked) { return; }\n    if (this.currentIndex === this.childViews.length - 1) {\n      this.hideViewIndex(this.currentIndex);\n      this.finish();\n      return;\n    }\n\n    this.navIndexChange(1);\n  },\n\n  navBackward: function() {\n    if (this.currentIndex === 0) {\n      return;\n    }\n\n    this.navIndexChange(-1);\n  },\n\n  navIndexChange: function(delta) {\n    this.hideViewIndex(this.currentIndex);\n    this.currentIndex += delta;\n    this.showViewIndex(this.currentIndex);\n  },\n\n  hideViewIndex: function(index) {\n    this.childViews[index].hide();\n  },\n\n  showViewIndex: function(index) {\n    this.childViews[index].show();\n  },\n\n  finish: function() {\n    // first we stop listening to keyboard and give that back to UI, which\n    // other views will take if they need to\n    this.keyboardListener.mute();\n\n    this.childViews.forEach(function(childView) {\n      childView.die();\n    });\n\n    this.deferred.resolve();\n  },\n\n  start: function() {\n    // steal the window focus baton\n    this.showViewIndex(this.currentIndex);\n  },\n\n  createChildView: function(viewJSON) {\n    var type = viewJSON.type;\n    if (!this.typeToConstructor[type]) {\n      throw new Error('no constructor for type \"' + type + '\"');\n    }\n    var view = new this.typeToConstructor[type](Object.assign(\n      {},\n      viewJSON.options,\n      { wait: true }\n    ));\n    return view;\n  },\n\n  addNavToView: function(view, index) {\n    var leftRight = new LeftRightView({\n      events: this.navEvents,\n      // we want the arrows to be on the same level as the content (not\n      // beneath), so we go one level up with getDestination()\n      destination: view.getDestination(),\n      showLeft: (index !== 0),\n      lastNav: (index === this.childViewJSONs.length - 1)\n    });\n    if (view.receiveMetaNav) {\n      view.receiveMetaNav(leftRight, this);\n    }\n  },\n\n  render: function() {\n    // go through each and render... show the first\n    this.childViewJSONs.forEach(function(childViewJSON, index) {\n      var childView = this.createChildView(childViewJSON);\n      this.childViews.push(childView);\n      this.addNavToView(childView, index);\n    }, this);\n  }\n});\n\nexports.MultiView = MultiView;\n",
                        "commit": {
                            "oid": "5e6af5d3720219eaa5a00e846df03861fc81b20e"
                        }
                    },
                    "lineMatches": [
                        {
                            "preview": "      childView.die();",
                            "lineNumber": 145,
                            "offsetAndLengths": [
                                [
                                    16,
                                    5
                                ]
                            ],
                            "limitHit": false
                        }
                    ]
                }
            ],
            "limitHit": false,
            "matchCount": 12,
            "elapsedMilliseconds": 12
        }
    }
}